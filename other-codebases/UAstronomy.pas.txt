unit UAstronomy;

interface
// astronomiskie algoritmi
procedure Suncoordinates(const jd:extended;var alpha:extended;var delta:extended);
Function JulianDay(const y, m, d, h:integer):extended;
function DateTimeToJulianDay(const dat:TdateTime):extended;
function JulianDayToDateTime(const jd:extended):TDateTime;
function siderealTime(const jd:extended):extended;
procedure SunHoriz(const jd:extended;const latitude,longitude:extended;var az,height:extended);



implementation
uses math;
// juliâna diena 1900,0,0
Const jd0 = 2415020;

// Jûlija diena
// h - UTC
Function JulianDay(const y, m, d, h:integer):extended;
var s,b:integer;
begin
 s := (12 - m) div  10;
 If y > 1582 Then
  b := 2 - (y div 100) + ((y div 100) div 4)
 Else
  b := 0;
 result := Int(365.25 * (y - s)) + Int(30.6001 * (m + 1 + 12 * s)) + d + 1720994.5 + b + 1.0/24.0*h;
End;

// UTC !!
function DateTimeToJulianDay(const dat:TdateTime):extended;
begin
 result:=dat+jd0-1.5;
end;

// UTC !!
function JulianDayToDateTime(const jd:extended):TDateTime;
begin
 result:=jd-jd0+1.5;
end;

// atgriez Saules ekvatorialas koordinates
// jd - julija diena
// alpha -
// delta - deklinacija
procedure Suncoordinates(const jd:extended;var alpha:extended;var delta:extended);
var t, L, Mr, e, C, omega, o, eps,so,co,se,ce:extended;
begin
 t := (jd - jd0) / 36525;
 L := 279.69668 + t*(36000.76892  + 0.0003025 * t);
 L := 360.0 * frac(1.0/360.0*L);
 Mr := 358.47583 + t*(35999.04975  +t*(- 0.00015  - 0.0000033 * t ));
 Mr := DegToRad(360.0 * frac(1.0/360.0*Mr));
 e := 0.01675104 +t*(- 0.0000418  - 0.000000126 * t );
 C := (1.91946 +t*(- 0.004789  - 0.000014 * t )) * Sin(Mr)
 + (0.020094 - 0.0001 * t) * Sin(2 * Mr) + 0.000293 * Sin(3 * Mr);
 omega := 25.18 - 1934.142 * t;
 omega := 360.0 * frac(1.0/360.0*omega);
 o := L + C - 0.00569 - 0.00479 * Sin(DegTorad(omega));
 eps := 23.452294 +t*(- 0.0130125 +t*( - 0.00000164  + 0.000000503 * t )) + 0.00256 * Cos(DegToRad(omega));
 SinCos(degtorad(o),so,co);
 SinCos(degtorad(eps),se,ce);
 alpha := radToDeg(Arctan2(ce* so,co));
 delta := radToDeg(Arcsin(se * so));
End;

Function eta0(const jd:extended):extended;
var t:extended;
begin
 t := 1.0/36525*(jd - jd0);
 result := 6.6460656 + t*(2400.051262  + 0.00002581 * t );
 result := 24.0 * frac(1.0/24.0*result);
End;
// UT!!!!
// zvaigþòu laiks stundâs
function siderealTime(const jd:extended):extended;
var jd0:extended;
    dj:Tdatetime;
    h:extended;
begin
 dj:=JulianDayToDateTime(jd);
 h:=24*frac(dj);
 jd0:=DateTimeToJulianDay(int(dj));
// result := eta0(y, m, d, 0#) + [longitude] / 15# + 1.002737908 * h
 result:=eta0(jd0)+ 1.002737908 * h;
 result := 24.0 * frac(1.0/24.0*result);
end;

procedure EkvCoordsToHorizCoords(const t, delta,latitude:extended;var a,z:extended);
var tr,dr,fr,sf,cf,sd,cd,st,ct:extended;
begin
 tr := degtoRad(t);
 dr := degtoRad(delta);
 fr := degtoRad(latitude);
 SinCos(fr,sf,cf);
 SinCos(dr,sd,cd);
 SinCos(tr,st,ct);
 z := radtodeg(Arccos(sf * sd + cf * cd * ct));
 a := radtodeg(Arctan2(-cd * st,-(-cf * sd + sf * cd * ct)));
End;

// laiks ==UT
procedure SunHoriz(const jd:extended;const latitude,longitude:extended;var az,height:extended);
var alpha,delta,eta:extended;
begin
 Suncoordinates(jd,alpha,delta);
 eta:=siderealTime(jd);
 EkvCoordsToHorizCoords(15*eta+longitude-alpha,delta,latitude,az,height);
 height:=90-height;
end;
end.
